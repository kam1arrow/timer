<!DOCTYPE html>
<html>

<head>
  <style type="text/css">
    .timer {
      font-size: 3vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      margin: auto;
      align-items: center;
    }
  </style>
</head>

<body>
  <div id="app">
    <div class="timer">
      <p>
        現在の状態：{{currentState}}<br>
        残り時間：{{ countDown }}<br>
        累積学習時間：{{ cumulativeTime }}<br>
        <input type="button" value="Press! (at least once)" onclick="alert('Thanks!');" />
        <!-- [idea]: 同じ設定で続けるボタン（promptから次回開始時刻を受け取り，breakpointに設定する．累積時間は据え置き．） -->
      </p>
    </div>
  </div>

</body>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.23.0/moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.23.0/locale/ja.js"></script>

<script type="text/javascript">
  var taiko = new Audio('taiko.mp3');
  var gong = new Audio('gong.mp3');

  const vm = new Vue({
    el: '#app',
    data: {
      countDown: '',
      paramsInURL: location.search,
      setCountLeft: 3,
      cumulativeTime_min: 0,
      cumulativeTime: '00:00',
      currentState: 'before_start', // reading, break
      timeToNextBreakpoint: NaN
    },
    computed: {
      queryDict: function () {
        query_dict = new Object;
        pairwise = this.paramsInURL.slice(1).split('&');
        for (i = 0; pairwise[i]; i++) {
          key_value = pairwise[i].split('=');
          query_dict[key_value[0]] = key_value[1];
        }
        return query_dict;
      },
      paramsForTimer: function () {
        // 時刻はすべて標準化（GMT+9:00）
        // durationは秒単位
        params = new Object;
        repeat = Number(this.queryDict['repeat']);
        reading_min = Number(this.queryDict['act']);
        interval_min = Number(this.queryDict['interval']);

        hour_min = this.queryDict['start'].split(':');
        start_time = moment().hour(Number(hour_min[0])).minutes(Number(hour_min[1])).second(0);

        total_duration_min = reading_min * repeat + interval_min * (repeat - 1);
        end_time = start_time.clone().add(moment.duration(total_duration_min, 'minutes'));

        return { start_time: start_time, end_time: end_time, num_repeat: repeat, duration_reading: reading_min, duration_interval: interval_min };
      },
    },
    methods: {
      refresh_counter: function () {
        // 基本的な計算の流れを，活動15分インターバル5分で活動するケースを取って説明
        // 開始時刻と現在時刻との差分がマイナス -> まだ始まっていない -> state: 開始前, breakpoint: 開始時刻
        // プラスの場合，差分を(15+5)で割った商はどのセットにいるのかを示し，余りは活動中（15以下）なのか休憩中（15より大）なのかを示す．
        // それぞれの場合に応じて，適切なstateとbreakpointを設定すればよい．
        this.timeToNextBreakpoint = this.paramsForTimer.start_time.clone();

        time_from_start = moment.duration(moment().diff(this.paramsForTimer['start_time'])).asMinutes();

        reading_plus_break = this.paramsForTimer['duration_reading'] + this.paramsForTimer['duration_interval'];

        // 現在のセット数（最初のセット=0）と残りセット数
        set_num = Math.floor(time_from_start / reading_plus_break);
        this.setCountLeft = this.paramsForTimer.num_repeat;

        if (set_num >= 0) {
          is_break = (time_from_start % reading_plus_break) > this.paramsForTimer.duration_reading;

          // ケースに応じて，state，設定すべきbreakpointまでの相対時間，累積時間，残りカウントの4つを設定
          if (is_break) {
            this.currentState = 'break';
            minutes_to_next_break_point = reading_plus_break * (set_num + 1);
            this.cumulativeTime_min = this.paramsForTimer.duration_reading * (set_num + 1);
            this.setCountLeft -= (set_num + 1);
          } else {
            this.currentState = 'reading';
            minutes_to_next_break_point = reading_plus_break * set_num + this.paramsForTimer.duration_reading;
            this.cumulativeTime_min = this.paramsForTimer.duration_reading * set_num;
            this.setCountLeft -= set_num;
          }

          this.timeToNextBreakpoint.add(moment.duration(minutes_to_next_break_point, 'minutes'));          

          // 以降例外処理
          if (vm.cumulativeTime_min > this.paramsForTimer.duration_reading * this.paramsForTimer.num_repeat) {
            vm.cumulativeTime_min = this.paramsForTimer.duration_reading * this.paramsForTimer.num_repeat; 
          }
          
          // moment.utcで60分未満のdurationを"hh:mm:ss"-formatで表示すると，12:52:00のようにhh=12となる
          if (vm.cumulativeTime_min < 60) {
            // vm.cumulativeTime = moment.utc(moment.duration(vm.cumulativeTime_min, 'minutes').asMilliseconds()).format("00:mm:ss");
            vm.cumulativeTime = moment.utc(moment.duration(vm.cumulativeTime_min, 'minutes').asMilliseconds()).format("mm:ss");
          }
          else {
            vm.cumulativeTime = moment.utc(moment.duration(vm.cumulativeTime_min, 'minutes').asMilliseconds()).format("hh:mm:ss");
          }
        }
      },
    },
  })

  vm.refresh_counter();

  id = setInterval(function () {

    const diff = vm.timeToNextBreakpoint.diff(moment());
    // [Fix] durationが一時間を超える場合，多分狂う．上のような例外処理が必要だが，面倒なので放置．
    vm.countDown = moment.utc(moment.duration(diff).asMilliseconds()).format("mm:ss");

    if (vm.countDown === '00:00') {
      switch (vm.currentState) {
        case 'before_start':
        case 'break':
          vm.timeToNextBreakpoint.add(moment.duration(vm.paramsForTimer.duration_reading, 'minutes'));
          vm.currentState = 'reading';
          taiko.play();
          break;
        case 'reading':
          vm.timeToNextBreakpoint.add(moment.duration(vm.paramsForTimer.duration_interval, 'minutes'));
          vm.currentState = 'break';
          gong.play();
          vm.setCountLeft--;
          vm.cumulativeTime_min += vm.paramsForTimer['duration_reading'];
          if (vm.cumulativeTime_min < 60) {
            vm.cumulativeTime = moment.utc(moment.duration(vm.cumulativeTime_min, 'minutes').asMilliseconds()).format("00:mm:ss");
          }
          else {
            vm.cumulativeTime = moment.utc(moment.duration(vm.cumulativeTime_min, 'minutes').asMilliseconds()).format("hh:mm:ss");
          }
          break;
      }
    }
    if (vm.setCountLeft <= 0) {
      vm.countDown = '';
        vm.currentState = 'finish';
        clearInterval(id);
    }
  }, 500);
</script>

</html>